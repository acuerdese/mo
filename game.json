// Game setup
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over');
const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');
const scoreDisplay = document.getElementById('score-display');
const finalScoreDisplay = document.getElementById('final-score');

// Set canvas size
function resizeCanvas() {
    const container = document.getElementById('game-container');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Game assets
const assets = {
    bird: new Image(),
    pipeTop: new Image(),
    pipeBottom: new Image(),
    background: new Image(),
    ground: new Image()
};

// Load assets from free sources
assets.bird.src = 'https://opengameart.org/sites/default/files/yellowbird-downflap.png';
assets.pipeTop.src = 'https://kenney.nl/content/3-assets/67-pipe-pack/pipeGreen_top.png';
assets.pipeBottom.src = 'https://kenney.nl/content/3-assets/67-pipe-pack/pipeGreen_bottom.png';
assets.background.src = 'https://opengameart.org/sites/default/files/background_1.png';
assets.ground.src = 'https://kenney.nl/content/3-assets/71-ground-pack/groundGrass.png';

// Game state
let gameRunning = false;
let score = 0;
let bestScore = 0;
let animationId = null;

// Game objects
const bird = {
    x: 50,
    y: canvas.height / 2,
    width: 34,
    height: 24,
    velocity: 0,
    gravity: 0.5,
    jump: -8,
    rotation: 0
};

const ground = {
    y: canvas.height - 50,
    height: 50,
    speed: 2
};

const pipes = {
    width: 60,
    gap: 150,
    list: [],
    lastTime: 0,
    frequency: 1500
};

// Game functions
function startGame() {
    gameRunning = true;
    score = 0;
    scoreDisplay.textContent = score;
    bird.y = canvas.height / 2;
    bird.velocity = 0;
    bird.rotation = 0;
    pipes.list = [];
    
    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';
    
    if (!animationId) {
        gameLoop();
    }
}

function gameLoop(timestamp) {
    if (!gameRunning) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw background
    ctx.drawImage(assets.background, 0, 0, canvas.width, canvas.height);
    
    // Draw ground
    const groundPattern = ctx.createPattern(assets.ground, 'repeat-x');
    ctx.fillStyle = groundPattern;
    ctx.fillRect(0, ground.y, canvas.width, ground.height);
    
    // Update and draw pipes
    updatePipes(timestamp);
    drawPipes();
    
    // Update and draw bird
    updateBird();
    drawBird();
    
    // Check collisions
    if (checkCollisions()) {
        endGame();
        return;
    }
    
    animationId = requestAnimationFrame(gameLoop);
}

function updatePipes(timestamp) {
    // Add new pipes
    if (timestamp - pipes.lastTime > pipes.frequency) {
        const gapPosition = Math.random() * (canvas.height - pipes.gap - ground.height - 100) + 50;
        pipes.list.push({
            x: canvas.width,
            topHeight: gapPosition,
            bottomY: gapPosition + pipes.gap,
            passed: false
        });
        pipes.lastTime = timestamp;
    }
    
    // Move pipes
    for (let i = pipes.list.length - 1; i >= 0; i--) {
        pipes.list[i].x -= 2;
        
        // Check if passed
        if (!pipes.list[i].passed && pipes.list[i].x + pipes.width < bird.x) {
            pipes.list[i].passed = true;
            score++;
            scoreDisplay.textContent = score;
        }
        
        // Remove off-screen pipes
        if (pipes.list[i].x + pipes.width < 0) {
            pipes.list.splice(i, 1);
        }
    }
}

function drawPipes() {
    pipes.list.forEach(pipe => {
        // Top pipe
        ctx.drawImage(
            assets.pipeTop,
            pipe.x,
            0,
            pipes.width,
            pipe.topHeight
        );
        
        // Bottom pipe
        ctx.drawImage(
            assets.pipeBottom,
            pipe.x,
            pipe.bottomY,
            pipes.width,
            canvas.height - pipe.bottomY - ground.height
        );
    });
}

function updateBird() {
    bird.velocity += bird.gravity;
    bird.y += bird.velocity;
    bird.rotation = Math.min(Math.max(bird.velocity * 5, -25), 25);
    
    // Keep bird on screen
    if (bird.y < 0) {
        bird.y = 0;
        bird.velocity = 0;
    }
}

function drawBird() {
    ctx.save();
    ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
    ctx.rotate(bird.rotation * Math.PI / 180);
    ctx.drawImage(
        assets.bird,
        -bird.width / 2,
        -bird.height / 2,
        bird.width,
        bird.height
    );
    ctx.restore();
}

function flap() {
    if (gameRunning) {
        bird.velocity = bird.jump;
    } else {
        startGame();
    }
}

function checkCollisions() {
    // Ground collision
    if (bird.y + bird.height / 2 > ground.y) {
        return true;
    }
    
    // Pipe collisions
    for (const pipe of pipes.list) {
        if (
            bird.x + bird.width / 2 > pipe.x &&
            bird.x - bird.width / 2 < pipe.x + pipes.width &&
            (bird.y - bird.height / 2 < pipe.topHeight ||
             bird.y + bird.height / 2 > pipe.bottomY)
        ) {
            return true;
        }
    }
    
    return false;
}

function endGame() {
    gameRunning = false;
    cancelAnimationFrame(animationId);
    animationId = null;
    
    // Update best score
    if (score > bestScore) {
        bestScore = score;
    }
    
    finalScoreDisplay.textContent = score;
    gameOverScreen.style.display = 'flex';
}

// Event listeners
startBtn.addEventListener('click', startGame);
restartBtn.addEventListener('click', startGame);

// Touch controls
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    flap();
});

canvas.addEventListener('mousedown', flap);

// Prevent scrolling on touch devices
document.addEventListener('touchmove', (e) => {
    if (gameRunning) {
        e.preventDefault();
    }
}, { passive: false });

// Initialize
resizeCanvas();
